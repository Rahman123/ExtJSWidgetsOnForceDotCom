<!-- 
Copyright 2012 Jeff Trull <jetrull@sbcglobal.net>

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
<apex:component controller="SlickbackRemotingCtrl">
	<!-- A SlickTable grid backed by Force.com data via Backbone.js and Slickback.js -->
    <apex:attribute name="object" type="String" description="sObject to generate a grid for" required="true"/>
    <apex:attribute name="fields" type="String[]" description="list of fields to display" required="true"/>
    <apex:attribute name="minimized" type="Boolean" description="whether to initially render the grid in minimized state" default="false"/>
    <apex:attribute name="rows" type="int" description="how many rows to display in grid" default="19"/>

<!-- contents of example.css -->
<style type="text/css">
#topLevel {
  height: 500px;
  width: 900px;
}

#exampleGrid {
  height: 460px;
  width: 100%;
  overflow: hidden;
}

#examplePager {
  width: 100%;
}

.alignRight {
  text-align: right;
}

.slick-cell input, .slick-cell select {
  height: 20px;
  width: 100%;
  padding: 0px;
  margin: 0px;
  border: 0px;
}

.slick-cell.alignRight input {
  text-align: right;
}

.slick-pager .slick-pager-settings {
  display: none;
}
</style>

<script>
   // content of model.js:
   (function() {
  "use strict";

  function read(method, model, options) {
    var dataParams = options.data || {};
  	// apply paging parameters
  	var pageSize    = parseInt('{!rows}');     // or let grid supply?
  	var page        = dataParams['page'] || 1;
  	var queryParams = {sobjname:    '{!object}',
			    	   fields:      '{!fields}',
			    	   start:       (page - 1)*pageSize,
			    	   recordCount: pageSize
    };
    if (('direction' in dataParams) && (dataParams.direction != null) &&
        ('order' in dataParams)     && (dataParams.order != null)) {
        queryParams.sortParams = [{ property:  dataParams.order,
        							direction: dataParams.direction
        						  }];
    }
    SlickbackRemotingCtrl.query(
    	queryParams,
    	function(resp, e) {
	    	if (!e.status || !resp.success) {  // TODO latter case is controller-generated; should pass on error message
	    		options.error(model, resp);
	    		return;
	    	}
		    options.success({ entries: resp.records,
		    			      currentPage:  page,
		    			      perPage:      pageSize,
		    			      totalEntries: resp.total
		    });
		});
  }

  function serverSync(method, model, options) {
  	switch(method) {
  		case 'read':
  			return read(method, model, options);
  		case 'update':
  			return simulatePaginatedUpdate(model, options);
  		default:
  			throw "Method " + method + "not implemented";
  			break;
  	}
  }

  function simulatePaginatedUpdate(model,options) {
    var offset = (model.id || 0) - 100;
    if (offset >= 0) { models[offset] = model.attributes; }
    options.success();
  }

  var productModel = Backbone.Model.extend({
    sync: serverSync,
    parse: function(response) {
    	// here is where we perform any translations between data returned from the
    	// server and what we want to store in each model
		// for now, just handle a (hardcoded) date field:
  		if (('Birthdate' in response) && !!response.Birthdate) {
  			// make it a Date (is a Javascript "time" on the wire!)
  			var d = new Date(parseInt(response.Birthdate));
  			response.Birthdate = new Date(d.getUTCFullYear(),
                 						   d.getUTCMonth(),
                 						   d.getUTCDate());
        }	  			
    	return response;
    }
  });

  var models = [];
  _.times(57,function(i) {
    var model = { 
      id:    (100 + i),
      FirstName:  ("First " + (1 + i)),
      LastName:   ("Last " + (1 + i)),
      Birthdate: new Date(),
      Email: 'bozo@test.com',
      Level__c: 'primary'
    };
    models.push(model);
  });

  /**
   * To use a real data source, don't implement sync and
   * provide the collection with a url which understands 
   * the pagination and sorting parameters, and which returns
   * paginated results.
   */
  var productsCollection = Slickback.PaginatedCollection.extend({
    model: productModel,
    sync:  serverSync
  });

  this.Example || (this.Example = {});
  this.Example.Models = { Product: productModel };
  this.Example.Collections = { Products: productsCollection };

}).call(this);
  
j$ = jQuery.noConflict();
j$(document).ready(function() {
    // instantiate model and view in DOM
	// construct columns from field metadata
    // decide whether to use "fieldset" or "fields".  Give "fields" priority (for manual override?)
    var fieldlist;
    var fields = '{!fields}';
    if ((fields == null) || (fields == '') || (fields == '[]')) {
        Ext.Msg.alert('no fields were supplied to this component');
        return;
    }
    if (fields.substr(0, 1) == '[') {
        // a fieldset - remove brackets and split on comma+space
        fieldlist = fields.substr(1, fields.length - 2).split(', ');
    } else {
        fieldlist = fields.split(',');
    }
    SlickbackRemotingCtrl.describeFields('{!object}', fieldlist,
        function(fieldData, e) {
            if (!e.status) {
            	throw 'Server error ' + e.message;   // TODO use modal dialog instead
            }
            var columns = [];
            for (var i = 0; i < fieldData.length; i++) {
                var col = {
                    id: fieldData[i].name,
                    field: fieldData[i].name,
                    name: fieldData[i].label,
                    sortable: fieldData[i].sortable,
                    width: 150
                }
                // special treatment for some data types
                if ((fieldData[i].fieldType == "date") || (fieldData[i].fieldType == "datetime")) {
                	col.formatter = function(row,cell,value,col,data) {
        				var dateobj = data.get(col.field);
        				// Let jQuery-UI do the formatting for us:
        				return dateobj ? j$.datepicker.formatDate('mm/dd/yy', dateobj) : '';
      				}
      			} else if (fieldData[i].fieldType == "picklist") {
      				col.formatter = Slickback.ChoiceFormatter;
      			}
                // set up editors for modifiable fields
                if (fieldData[i].modifiable) {
                	col.editable = true;
                	// special editors for certain data types
                	if (fieldData[i].fieldType == "double") {
                		col.editor = Slickback.NumberCellEditor;
                	} else if (fieldData[i].fieldType == "integer") {
                		col.editor = Slickback.IntegerCellEditor;
                	} else if (fieldData[i].fieldType == "date") {
                		col.editor = Slick.Editors.Date;  // unclear if this actually works...
                	} else if (fieldData[i].fieldType == "picklist") {
                		col.editor = Slickback.DropdownCellEditor;
                		// add choice values
                		col.choices = [];
                		for (var j=0; j< fieldData[i].picklistValues.length; j++) {
                			if (fieldData[i].picklistValues[j].length > 1) {  // skip nillable values
                				col.choices.push({ label: fieldData[i].picklistValues[j][0],
                							   	   value: fieldData[i].picklistValues[j][1]
                							     });
                			}
                		}
                	} else {
                		col.editor = Slickback.TextCellEditor;
                	}
                }
                columns.push(col);
              }

			  function initializeProductsGridView(initializationOpts) {
			    this.pager  = initializationOpts.pager;
			
			    var gridOptions = _.extend({},{
			        editable:         true,
			        formatterFactory: Slickback.BackboneModelFormatterFactory
			    },initializationOpts.grid);
			
			    var collection = this.collection;
			
			    var grid =
			      new Slick.Grid(this.el,collection,columns,gridOptions);
			    var pager =
			      new Slick.Controls.Pager(collection,grid,this.pager);
			
			    grid.onSort.subscribe(function(e, msg) {
			        collection.extendScope({
			            order:     msg.sortCol.field,
			            direction: (msg.sortAsc ? 'ASC' : 'DESC')
			        });
			        collection.fetchWithScope(); // NOTE: resetting pagination
			    });
			
			    collection.bind('change',function(model,attributes) {
			        model.save();
			    });
			
			    collection.onRowCountChanged.subscribe(function() {
			        grid.updateRowCount();
			        grid.render();
			    });
			
			    collection.onRowsChanged.subscribe(function() {
			        grid.invalidateAllRows();
			        grid.render();
			    });
			
			    collection.fetchWithPagination();
			  }
			
			  var productsGridView = Backbone.View.extend({
			      initialize: initializeProductsGridView
			  });
			
			  this.Example || (this.Example = {});
			  this.Example.Views = { ProductsGrid: productsGridView   };

		      var products = new Example.Collections.Products();
		      var view     = new Example.Views.ProductsGrid({
		        el:         '#exampleGrid',
		        collection: products,
		        pager:      j$('#examplePager')
		      });
          });
});
</script>
<div id="topLevel">
	<div class="grid-header" style="width:100%">
		<label>{!object}</label>
	</div>
    <div id="exampleGrid"></div>
    <div id="examplePager"></div>
</div>

</apex:component>